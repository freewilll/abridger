- title: Subjects
  doc_filename: examples_subjects
  schema: examples-schema-subjects.sql
  examples:
  - title: All departments
    ref: example_subjects_all_departments
    description: A table entry with just a table name will fetch all rows.
    short_description: A table entry with just a table name will fetch all rows for that table
    config:
      - subject:
        - tables:
          - {table: departments}
    expected_statements:
      - INSERT INTO departments (id, name) VALUES(1, 'Research');
      - INSERT INTO departments (id, name) VALUES(2, 'Accounting');
      - INSERT INTO departments (id, name) VALUES(3, 'Finance');
  - title: One department
    ref: example_subjects_one_department
    description: A table entry with a single column/value will fetch one row.
    short_description: A table entry with a single column/value will fetch one row
    config:
      - subject:
        - tables:
          - {table: departments, column: name, values: Research}
    expected_statements:
      - INSERT INTO departments (id, name) VALUES(1, 'Research');
  - title: Two departments
    ref: example_subjects_two_departments
    description: A table entry with multiple column/value will fetch multiple rows.
    short_description: A table entry with multiple column/value will fetch multiple rows
    config:
      - subject:
        - tables:
          - {table: departments, column: name, values: ['Research', 'Accounting']}
    expected_statements:
      - INSERT INTO departments (id, name) VALUES(1, 'Research');
      - INSERT INTO departments (id, name) VALUES(2, 'Accounting');

# ------------------------------------------------------------------------------------------------------------------------
- title: Defaults
  doc_filename: examples_defaults
  schema: examples-schema-defaults.sql
  examples:
  - title: all-outgoing-not-null
    ref: example_relations_all_outgoing_not_null
    description: |
      ``all-outgoing-not-null`` is the minimum required relation.
      Nullable outgoing foreign keys are ignored, as well as incoming foreign keys.
      Fetching all ``departments`` with this setting will make the ``building_id`` foreign key ``null``.
      Also, since no incoming relations are in the defaults, no rows in ``employees`` are fetched.
      If rows in ``buildings`` are required, they can be enabled by adding an ``outoing`` relation from ``departments`` to ``buildings``. This will also make the ``null`` go away in the "Research" department.
    short_description: all-outgoing-not-null
    config:
      - relations:
          - {defaults: all-outgoing-not-null}
      - subject:
        - tables:
          - {table: departments}
    expected_statements:
      - INSERT INTO departments (id, name, building_id) VALUES(1, 'Research', NULL);
      - INSERT INTO departments (id, name, building_id) VALUES(2, 'Accounting', NULL);

  - title: all-outgoing-nullable
    ref: example_relations_all_outgoing_nullable
    description: |
      ``all-outgoing-nullable`` ensures that for any row that is fetched all foreign keys are processed.
      In this example it means that the ``buildings`` row with id=1 must be fetched to satisfy the ``building_id`` foreign key constraint on the ``departments`` table.
      Also, since no incoming relations are in the defaults, no rows in ``employees`` are fetched.
    short_description: all-outgoing-nullable
    config:
      - relations:
          - {defaults: all-outgoing-nullable}
      - subject:
        - tables:
          - {table: departments}
    expected_statements:
      - INSERT INTO buildings (id, name) VALUES(1, 'London');
      - INSERT INTO departments (id, name, building_id) VALUES(1, 'Research', 1);
      - INSERT INTO departments (id, name, building_id) VALUES(2, 'Accounting', NULL);

  - title: all-incoming
    ref: example_relations_all_incoming
    description: |
      ``all-incoming`` ensures that for any row that is fetched all *referencing* foreign keys are processed in other tables.
      In this example it means that that all ``employees`` with ``department_id`` in the fetched departments are fetched.
      Note how no rows in ``buildings`` are fetched, since ``all-outgoing-nullable`` wasn't enabled.
    short_description: all-incoming
    config:
      - relations:
          - {defaults: all-incoming}
      - subject:
        - tables:
          - {table: departments}
    expected_statements:
     - INSERT INTO departments (id, name, building_id) VALUES(1, 'Research', NULL);
     - INSERT INTO departments (id, name, building_id) VALUES(2, 'Accounting', NULL);
     - INSERT INTO employees (id, name, department_id) VALUES(1, 'John', 1);
     - INSERT INTO employees (id, name, department_id) VALUES(2, 'Jane', 1);
     - INSERT INTO employees (id, name, department_id) VALUES(3, 'Janet', 2);

  - title: all-incoming and all-outgoing-nullable
    ref: example_relations_all_incoming_and_all_outgoing_nullable
    description: |
      The combination of ``all-outgoing-nullable`` and ``all-incoming``, which is equivalent to ``everything``, fetches everything in ``buildings`` and ``employees`` related to all the ``departments``.
    short_description: all-incoming and all-outgoing-nullable
    config:
      - relations:
          - {defaults: all-outgoing-nullable}
          - {defaults: all-incoming}
      - subject:
        - tables:
          - {table: departments}
    expected_statements:
      - INSERT INTO buildings (id, name) VALUES(1, 'London');
      - INSERT INTO departments (id, name, building_id) VALUES(1, 'Research', 1);
      - INSERT INTO departments (id, name, building_id) VALUES(2, 'Accounting', NULL);
      - INSERT INTO employees (id, name, department_id) VALUES(1, 'John', 1);
      - INSERT INTO employees (id, name, department_id) VALUES(2, 'Jane', 1);
      - INSERT INTO employees (id, name, department_id) VALUES(3, 'Janet', 2);

# ------------------------------------------------------------------------------------------------------------------------
- title: Relations
  doc_filename: examples_relations
  schema: examples-schema-defaults.sql
  examples:
  - title: Default relations for a department
    ref: example_default_relations_for_a_department
    description: |
      By default, complete rows are fetched.
      This means that if a rule is added to fetch the department with name "Research" then rows referencing that department aren't fetched.
      However departments reference buildings, so all buildings referenced from departments will be fetched.
    short_description: Default relations for a department
    config:
      - subject:
        - tables:
          - {table: departments, column: name, values: Research}
    expected_statements:
      - INSERT INTO buildings (id, name) VALUES(1, 'London');
      - INSERT INTO departments (id, name, building_id) VALUES(1, 'Research', 1);

  - title: Incoming Relation
    ref: incoming_relation1
    description: |
      This does an extraction with a relation from ``employees`` to ``departments``. This will include both employees in the research department.
      Note how rows in ``buildings`` are also included since by the default all outgoing foreign keys are fetched. See :ref:`defaults` for more details.
      The ``type`` of ``incoming`` doesn't have to be included in the config since this is the default.
    short_description: Incoming Relation
    config:
      - subject:
        - tables:
          - {table: departments, column: name, values: Research}
        - relations:
          - {table: employees, column: department_id}
    expected_statements:
      - INSERT INTO buildings (id, name) VALUES(1, 'London');
      - INSERT INTO departments (id, name, building_id) VALUES(1, 'Research', 1);
      - INSERT INTO employees (id, name, department_id) VALUES(1, 'John', 1);
      - INSERT INTO employees (id, name, department_id) VALUES(2, 'Jane', 1);

  - title: Relation for two departments 1
    ref: example_relations_two_departments1
    description: |
      This does an extraction with the above relation, but with both departments.
      This ends up fetching all employees.
    short_description: Default relations for two departments
    config:
    - subject:
      - tables:
        - {table: departments, column: name, values: [Research, Accounting]}
      - relations:
        - {table: employees, column: department_id}
    expected_statements:
      - INSERT INTO buildings (id, name) VALUES(1, 'London');
      - INSERT INTO departments (id, name, building_id) VALUES(1, 'Research', 1);
      - INSERT INTO departments (id, name, building_id) VALUES(2, 'Accounting', NULL);
      - INSERT INTO employees (id, name, department_id) VALUES(1, 'John', 1);
      - INSERT INTO employees (id, name, department_id) VALUES(2, 'Jane', 1);
      - INSERT INTO employees (id, name, department_id) VALUES(3, 'Janet', 2);

  - title: Relation for two departments 2
    ref: example_relations_two_departments2
    description: This is equivalent to :ref:`example_relations_two_departments1`, except it used two separate table sections.
    short_description: An alternative default relations for two departments
    config:
    - relations:
      - {table: employees, column: department_id}
    - subject:
      - tables:
        - {table: departments, column: id, values: 1}
        - {table: departments, column: id, values: 2}
    expected_statements:
      - INSERT INTO buildings (id, name) VALUES(1, 'London');
      - INSERT INTO departments (id, name, building_id) VALUES(1, 'Research', 1);
      - INSERT INTO departments (id, name, building_id) VALUES(2, 'Accounting', NULL);
      - INSERT INTO employees (id, name, department_id) VALUES(1, 'John', 1);
      - INSERT INTO employees (id, name, department_id) VALUES(2, 'Jane', 1);
      - INSERT INTO employees (id, name, department_id) VALUES(3, 'Janet', 2);

  - title: Relation for two departments 3
    ref: example_relations_two_departments3
    description: This is equivalent to :ref:`example_relations_two_departments1`, except it used two separate subjects.
    short_description: Another alternative default relations for two departments
    config:
    - relations:
      - {table: employees, column: department_id}
    - subject:
      - tables:
        - {table: departments, column: id, values: 1}
    - subject:
      - tables:
        - {table: departments, column: name, values: Accounting}
    expected_statements:
      - INSERT INTO buildings (id, name) VALUES(1, 'London');
      - INSERT INTO departments (id, name, building_id) VALUES(1, 'Research', 1);
      - INSERT INTO departments (id, name, building_id) VALUES(2, 'Accounting', NULL);
      - INSERT INTO employees (id, name, department_id) VALUES(1, 'John', 1);
      - INSERT INTO employees (id, name, department_id) VALUES(2, 'Jane', 1);
      - INSERT INTO employees (id, name, department_id) VALUES(3, 'Janet', 2);

  - title: Relation for an employee
    ref: example_relations_an_employee
    description: |
      This includes all relations. This leads to all employees in the research department being fetched since:

      - John belongs to the research department
      - All employees in the research department are fetched, which pulls in Jane
    short_description: All relations
    config:
      - relations:
          - { defaults: everything}
      - subject:
        - tables:
          - {table: employees, column: name, values: John}
    expected_statements:
      - INSERT INTO buildings (id, name) VALUES(1, 'London');
      - INSERT INTO departments (id, name, building_id) VALUES(1, 'Research', 1);
      - INSERT INTO employees (id, name, department_id) VALUES(1, 'John', 1);
      - INSERT INTO employees (id, name, department_id) VALUES(2, 'Jane', 1);

  - title: Outgoing relation
    ref: outgoing_relation
    description: |
      This shows the explicit enabling of an outgoing nullable relation when using the minimal defaults of ``all-outgoing-not-null``.
      Without the relation, no rows in the ``buildings`` table would be fetched, since the default rules don't including following nullable foreign keys.
      In this example, the relation is enabled, resulting in building being included.
    short_description: Outgoing relation
    config:
      - relations:
          - {defaults: all-outgoing-not-null}
      - subject:
        - tables:
          - {table: departments, column: name, values: ['Research', 'Accounting']}
        - relations:
          - {table: departments, column: building_id, type: outgoing}
    expected_statements:
     - INSERT INTO buildings (id, name) VALUES(1, 'London');
     - INSERT INTO departments (id, name, building_id) VALUES(1, 'Research', 1);
     - INSERT INTO departments (id, name, building_id) VALUES(2, 'Accounting', NULL);

  - title: Disabled incoming relation
    ref: example_relations_disabled_incoming
    description: |
      This demonstrates the blacklisting approach. All relations are included by default,
      however the relation from ``employees`` to ``departments`` is disabled.
      Fetching a department will therefore not fetch any of the employees.

      This is an ``incoming`` relationship type from the perspective of the ``employees`` table.
      The ``type`` key doesn't have to be included since the default type is ``incoming``.
      Relations can be disabled globally or per subject.
      The ``type`` of a relationship is ``incoming`` by default.
    short_description: Blacklisting approach using disabled relations
    config:
      - relations:
          - { defaults: everything}
      - subject:
        - tables:
          - {table: departments, column: name, values: ['Research', 'Accounting']}
        - relations:
          - {table: employees, column: department_id, disabled: true}
    expected_statements:
      - INSERT INTO buildings (id, name) VALUES(1, 'London');
      - INSERT INTO departments (id, name, building_id) VALUES(1, 'Research', 1);
      - INSERT INTO departments (id, name, building_id) VALUES(2, 'Accounting', NULL);


  - title: Disabled outgoing relation
    ref: example_relations_disabled_outgoing
    description: |
      This is another example of the blacklisting approach. All relations are included by default,
      however the relation from ``departments`` to ``buildings`` is disabled.
      Fetching a department will therefore not fetch any of the buildings.
      This is an ``outgoing`` relationship type from the perspective of the ``departments`` table due to the ``building_id`` foreign key.
      A side effect of disabling this relation is that ``building_id`` becomes ``null`` for the "Research" department, even though the "Research" department is associated with the "London" building.
    short_description: Blacklisting approach using disabled relations
    config:
      - relations:
          - { defaults: everything}
      - subject:
        - tables:
          - {table: departments, column: name, values: ['Research', 'Accounting']}
        - relations:
          - {table: departments, column: building_id, disabled: true, type: outgoing}
    expected_statements:
     - INSERT INTO departments (id, name, building_id) VALUES(1, 'Research', NULL);
     - INSERT INTO departments (id, name, building_id) VALUES(2, 'Accounting', NULL);
     - INSERT INTO employees (id, name, department_id) VALUES(1, 'John', 1);
     - INSERT INTO employees (id, name, department_id) VALUES(2, 'Jane', 1);
     - INSERT INTO employees (id, name, department_id) VALUES(3, 'Janet', 2);

- title: Compound Foreign Keys
  doc_filename: examples_compound_foreign_keys
  schema: examples-schema-compound-foreign-keys.sql
  make_table: false
  examples:
  - title: Compound Foreign Keys
    ref: examples_compound_foreign_keys
    description: This extermely convoluted example shows that compound foreign key support is built in. Relations can also be used, but only one column can be matched if the foreign key is a compound one.
    short_description: Compound Foreign Keys
    config:
      - relations:
          - {defaults: everything}
      - subject:
        - tables:
          - {table: departments}
    expected_statements:
     - INSERT INTO buildings (id1, id2, name) VALUES(1, 1, 'London');
     - INSERT INTO departments (id1, id2, name, building1_id, building2_id) VALUES(1, 1, 'Research', 1, 1);
     - INSERT INTO departments (id1, id2, name, building1_id, building2_id) VALUES(2, 2, 'Accounting', NULL, NULL);
     - INSERT INTO employees (id1, id2, name, department1_id, department2_id) VALUES(1, 1, 'John', 1, 1);
     - INSERT INTO employees (id1, id2, name, department1_id, department2_id) VALUES(2, 2, 'Jane', 1, 1);
     - INSERT INTO employees (id1, id2, name, department1_id, department2_id) VALUES(3, 3, 'Janet', 2, 2);
